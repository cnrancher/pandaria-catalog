package checker

import (
	"archive/tar"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	hangarUtils "github.com/cnrancher/hangar/pkg/utils"
	"github.com/klauspost/pgzip"
	"golang.org/x/mod/semver"
	"helm.sh/helm/v3/pkg/repo"

	mmSemver "github.com/Masterminds/semver/v3"
	"github.com/cnrancher/hangar/pkg/rancher/chartimages"
	"github.com/cnrancher/pandaria-catalog/check/pkg/chartpackages"
	"github.com/cnrancher/pandaria-catalog/check/pkg/utils"
	"github.com/sirupsen/logrus"
)

type Checker struct {
	Path           string
	RancherVersion string

	// loadedIndex is the index.yaml file built by chart-build-scripts
	loadedIndex *repo.IndexFile
	// builtIndex is the index object generated by walk through charts/ dir
	builtIndex *repo.IndexFile
	// packageIndex is the index object generated by walk through packages/ dir
	packageIndex *repo.IndexFile
}

func NewChecker(p, v string) *Checker {
	return &Checker{
		Path:           p,
		RancherVersion: v,
	}
}

func (cc *Checker) init() error {
	var err error
	cc.loadedIndex, err = repo.LoadIndexFile(
		filepath.Join(cc.Path, "index.yaml"))
	if err != nil {
		return fmt.Errorf("repo.LoadIndexFile: %q: %v", cc.Path, err)
	}
	if len(cc.loadedIndex.Entries) == 0 {
		return fmt.Errorf("no charts found in %q",
			filepath.Join(cc.Path, "index.yaml"))
	}

	cc.builtIndex, err = chartimages.BuildOrGetIndex(
		filepath.Join(cc.Path, "charts"))
	if err != nil {
		return fmt.Errorf("chartimages.BuildOrGetIndex: %q: %v", cc.Path, err)
	}
	if len(cc.builtIndex.Entries) == 0 {
		return fmt.Errorf("no charts found in %q",
			filepath.Join(cc.Path, "charts"))
	}

	cc.packageIndex, err = chartpackages.BuildIndex(
		filepath.Join(cc.Path, "packages"))
	if err != nil {
		return fmt.Errorf("chartpackages.BuildIndex: %q: %v", cc.Path, err)
	}
	if len(cc.packageIndex.Entries) == 0 {
		return fmt.Errorf("no charts found in %q",
			filepath.Join(cc.Path, "packages"))
	}

	return nil
}

func (cc *Checker) Check() error {
	if cc.Path == "" {
		return fmt.Errorf("chart path not specified")
	}
	if !semver.IsValid(cc.RancherVersion) {
		return fmt.Errorf("%q is not valid version", cc.RancherVersion)
	}
	if !hangarUtils.SemverMajorEqual(cc.RancherVersion, "v2.7") &&
		!hangarUtils.SemverMajorEqual(cc.RancherVersion, "v2.6") {
		return fmt.Errorf("checker program only supports v2.7 & v2.6")
	}

	var err error
	if cc.Path, err = hangarUtils.GetAbsPath(cc.Path); err != nil {
		return err
	}

	if err := cc.init(); err != nil {
		return err
	}
	var failed bool
	if err := cc.chartsBuildScriptsCheck(); err != nil {
		logrus.Error(err)
		return fmt.Errorf("charts-build-scripts check failed, abort")
	}

	if err := cc.annotationCheck(); err != nil {
		logrus.Error(err)
		failed = true
	}
	if err := cc.imageCheck(); err != nil {
		logrus.Error(err)
		failed = true
	}
	if err := cc.systemDefaultRegistryCheck(); err != nil {
		logrus.Error(err)
		failed = true
	}

	if failed {
		return fmt.Errorf("check failed")
	}
	return nil
}

func (cc *Checker) chartsBuildScriptsCheck() error {
	logrus.Infof(utils.SEPARATOR)
	logrus.Infof("start charts-build-scripts check...")

	var errs []string

	for name, versions := range cc.loadedIndex.Entries {
		if name == "" {
			errs = append(errs,
				"chart name in index.yaml file is empty")
		}

		if len(versions) == 0 {
			errs = append(errs,
				fmt.Sprintf("chart %q does not have versions", name))
		}

		for _, version := range versions {
			if len(version.URLs) == 0 {
				errs = append(errs,
					fmt.Sprintf("chart %q, version %q does not have URL",
						name, version.Version))
				continue
			}

			// ensure URL suffix is tgz and the file exists
			for _, url := range version.URLs {
				if !strings.HasSuffix(url, ".tgz") {
					errs = append(errs,
						fmt.Sprintf("chart url %q is not a tgz file", url))
					continue
				}

				info, err := os.Stat(filepath.Join(cc.Path, url))
				if err != nil {
					if os.IsNotExist(err) {
						errs = append(errs,
							fmt.Sprintf("%q does not exists", url))
						continue
					}
					logrus.Error("failed to get info of file %q: %v",
						filepath.Join(cc.Path, url), err)
					continue
				}
				if info.IsDir() {
					errs = append(errs, fmt.Sprintf("%q is a directory", url))
				}
			}
		}
	}

	// compare loaded Index with built Index
	if len(cc.loadedIndex.Entries) != len(cc.builtIndex.Entries) {
		return fmt.Errorf("chart num in index.yaml is %v != 'chart/' dir: %v",
			len(cc.loadedIndex.Entries), len(cc.builtIndex.Entries))
	}
	for name, bVersions := range cc.builtIndex.Entries {
		lVersions, ok := cc.loadedIndex.Entries[name]
		if !ok {
			errs = append(errs,
				fmt.Sprintf("index.yaml does not have chart: %v", name))
			continue
		}
		if len(bVersions) != len(lVersions) {
			errs = append(errs,
				fmt.Sprintf("chart %q built versions num %v "+
					"not equal to loaded versions num %v",
					name, len(bVersions), len(lVersions)))
		}
		// compare charts
		for i := 0; i < len(bVersions); i++ {
			err := utils.CompareChart(bVersions[i], lVersions[i])
			if err != nil {
				errs = append(errs,
					fmt.Sprintf("chart %q failed to compare: %v", name, err))
			}
		}
	}

	// compare built index with charts in packages dir
	if len(cc.loadedIndex.Entries) != len(cc.packageIndex.Entries) {
		return fmt.Errorf("chart num in index.yaml is %v != 'packages/' dir: %v",
			len(cc.loadedIndex.Entries), len(cc.packageIndex.Entries))
	}
	for name, pVersions := range cc.packageIndex.Entries {
		lVersions, ok := cc.loadedIndex.Entries[name]
		if !ok {
			errs = append(errs,
				fmt.Sprintf("index.yaml does not have chart: %v", name))
			continue
		}
		if len(pVersions) != len(lVersions) {
			errs = append(errs,
				fmt.Sprintf("chart %q packages versions num %v "+
					"not equal to loaded versions num %v",
					name, len(pVersions), len(lVersions)))
		}
		// compare charts
		for i := 0; i < len(pVersions); i++ {
			err := utils.CompareChart(pVersions[i], lVersions[i])
			if err != nil {
				errs = append(errs,
					fmt.Sprintf("chart %q failed to compare: %v", name, err))
			}
		}
	}

	if len(errs) != 0 {
		return fmt.Errorf("charts-build-scripts verify failed:\n%v",
			strings.Join(errs, "\n"))
	}

	logrus.Infof("charts-build-scripts check passed")
	return nil
}

func (cc *Checker) annotationCheck() error {
	logrus.Infof(utils.SEPARATOR)
	logrus.Infof("start annotation check...")
	rvList := []string{}
	kvList := []string{}
	annotationCheckFailed := false
	for _, versions := range cc.loadedIndex.Entries {
		if len(versions) == 0 {
			continue
		}
		lv := versions[0]
		msg := fmt.Sprintf("%s:%s", lv.Name, lv.Version)
		rv, ok := lv.Annotations[utils.RancherVersionAnnotationKey]
		if !ok {
			logrus.Errorf("FAILED: No rancher-version annotation: %s", msg)
			rvList = append(rvList, msg)
		} else {
			logrus.Infof("found rancher-version of %q: %q",
				lv.Name, rv)
			if _, err := mmSemver.NewConstraint(rv); err != nil {
				logrus.Errorf("%q is not a valid constraint str: %v", rv, err)
				rvList = append(rvList, msg)
			}
		}
		kv, ok := lv.Annotations[utils.KubeVersionAnnotationKey]
		if !ok {
			logrus.Errorf("FAILED: No kube-version annotation: %s", msg)
			kvList = append(kvList, msg)
		} else {
			logrus.Infof("found kube-version of %q: %q",
				lv.Name, kv)
			if _, err := mmSemver.NewConstraint(kv); err != nil {
				logrus.Errorf("%q is not a valid constraint str: %v", kv, err)
				kvList = append(kvList, msg)
			}
		}
	}

	if len(rvList) != 0 {
		hangarUtils.SaveSlice(utils.NoRancherVersionFile, rvList)
		annotationCheckFailed = true
	}
	if len(kvList) != 0 {
		hangarUtils.SaveSlice(utils.NoKubeVersionFile, kvList)
		annotationCheckFailed = true
	}
	if annotationCheckFailed {
		return fmt.Errorf("annotation check failed")
	} else {
		logrus.Infof("annotation check passed")
	}

	return nil
}

func (cc *Checker) imageCheck() error {
	logrus.Infof(utils.SEPARATOR)
	logrus.Infof("start image check...")
	failedList := []string{}
	for _, versions := range cc.loadedIndex.Entries {
		if len(versions) == 0 {
			continue
		}
		lv := versions[0]
		hidden, ok := lv.Annotations[utils.HiddenAnnotationKey]
		if ok && hidden == "true" {
			logrus.Infof("skip hidden charts: %v:%v", lv.Name, lv.Version)
			continue
		}
		if len(lv.URLs) == 0 {
			logrus.Warnf("url of %q is empty", lv.Name)
			continue
		}
		values, err := cc.getChartValues(lv.URLs[0])
		if err != nil {
			logrus.Error(err)
			continue
		}
		if len(values) == 0 {
			logrus.Warnf("chart %v:%v does not have values.yaml",
				lv.Name, lv.Version)
			continue
		}
		var imageSet = make(map[string]map[string]bool)
		err = chartimages.PickImagesFromValuesMap(
			imageSet, values[0], "", chartimages.Linux)
		if err != nil {
			logrus.Warn(err)
		}
		err = chartimages.PickImagesFromValuesMap(
			imageSet, values[0], "", chartimages.Windows)
		if err != nil {
			logrus.Warn(err)
		}
		msg := fmt.Sprintf("%s:%s", lv.Name, lv.Version)
		var foundImage bool = false
		var imageValid bool = true
		for image := range imageSet {
			project := hangarUtils.GetProjectName(image)
			if project != "rancher" && project != "cnrancher" {
				logrus.Errorf("The project of image %q in chart %q is neithor "+
					"'rancher' nor 'cnrancher'", image, msg)
				imageValid = false
			}
			foundImage = true
		}
		if foundImage && imageValid {
			logrus.Infof("PASS: %v", msg)
		} else if !foundImage {
			logrus.Errorf("FAILED: no images found from chart: %v", msg)
			failedList = append(failedList, msg)
		} else {
			logrus.Errorf("FAILED: project name of images in chart %q "+
				"does not valid", msg)
			failedList = append(failedList, msg)
		}
	}
	if len(failedList) != 0 {
		hangarUtils.SaveSlice(utils.ImageCheckFailedFile, failedList)
		return fmt.Errorf("chart image check failed")
	}
	logrus.Infof("image check passed")

	return nil
}

func (cc *Checker) systemDefaultRegistryCheck() error {
	logrus.Infof(utils.SEPARATOR)
	logrus.Infof("start systemDefaultRegistry check...")
	failedList := []string{}
	for _, versions := range cc.loadedIndex.Entries {
		if len(versions) == 0 {
			continue
		}
		lv := versions[0]
		hidden, ok := lv.Annotations[utils.HiddenAnnotationKey]
		if ok && hidden == "true" {
			logrus.Infof("skip hidden charts: %v:%v", lv.Name, lv.Version)
			continue
		}
		msg := fmt.Sprintf("%s:%s", lv.Name, lv.Version)
		values, err := cc.getChartValues(lv.URLs[0])
		if err != nil {
			logrus.Errorf("failed to get %q values.yaml: %v", lv.URLs[0], err)
			failedList = append(failedList, msg)
			continue
		}
		if len(values) == 0 {
			logrus.Warnf("%q does not have values.yaml", msg)
			continue
		}
		tmplString, err := cc.getChartHelperTemplate(lv.URLs[0])
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				logrus.Warnf("%q does not have '_helpers.tpl'", lv.URLs[0])
				// failedList = append(failedList, msg)
				continue
			}
			logrus.Errorf("failed to get the content of %q '_helpers.tpl': %v",
				lv.URLs[0], err)
			failedList = append(failedList, msg)
			continue
		}

		tmplString = fmt.Sprintf("%v\nTEST: {{ template %q . }}\n",
			tmplString, "system_default_registry")
		tmpl, err := template.New(lv.URLs[0]).
			Funcs(fakeFuncsMap).Parse(tmplString)
		if err != nil {
			logrus.Errorf("failed to parse template %q: %v", lv.URLs[0], err)
			failedList = append(failedList, msg)
			continue
		}

		// Check global.systemDefaultRegistry or
		// global.cattle.systemDefaultRegistry is defined in values.yaml

		// global:
		//   systemDefaultRegistry: docker.io
		//   cattle:
		//     systemDefaultRegistry: docker.io
		var systemDefaultRegistryDefined bool = false
		global, ok := values[0]["global"].(map[any]any)
		if !ok {
			logrus.Warnf("'global' not defined in chart %q values.yaml", msg)
			values[0]["global"] = make(map[any]any)
			global = values[0]["global"].(map[any]any)
		}
		if _, ok := global["systemDefaultRegistry"]; ok {
			systemDefaultRegistryDefined = true
		}
		global["systemDefaultRegistry"] = "registry.example.io"
		cattle, ok := global["cattle"].(map[any]any)
		if !ok {
			global["cattle"] = make(map[any]any)
			cattle = global["cattle"].(map[any]any)
		}
		if _, ok := cattle["systemDefaultRegistry"]; ok {
			systemDefaultRegistryDefined = true
		}
		cattle["systemDefaultRegistry"] = "registry.example.io"
		if !systemDefaultRegistryDefined &&
			hangarUtils.SemverMajorMinorEqual(cc.RancherVersion, "v2.7") {
			// v2.7 requires systemDefaultRegistry defined in chart values.yaml
			logrus.Errorf("systemDefaultRegistry not defined in %q values.yaml",
				msg)
			failedList = append(failedList, msg)
			continue
		}

		buff := bytes.Buffer{}
		err = tmpl.Execute(&buff, struct {
			Values any `json:"Values"`
		}{Values: values[0]})
		if err != nil {
			logrus.Errorf("FAILED: template.Execute failed: %v", err)
			failedList = append(failedList, msg)
			continue
		}
		rendered := buff.String()

		if strings.Contains(rendered, "TEST: registry.example.io") {
			// the systemDefaultRegistry is effective
			logrus.Infof("PASS: %v - %v", lv.Name, lv.Version)
		} else {
			logrus.Errorf("FAILED: %s", msg)
			failedList = append(failedList, msg)
		}
	}

	if len(failedList) != 0 {
		hangarUtils.SaveSlice(
			utils.SystemDefaultRegistryCheckFailed, failedList)
		return fmt.Errorf("systemDefaultRegistry check failed")
	}
	logrus.Infof("systemDefaultRegistry check passed")
	return nil
}

func (cc *Checker) getChartValues(chartURL string) ([]map[any]any, error) {
	chartPath := filepath.Join(cc.Path, chartURL)
	info, err := os.Stat(chartPath)
	if err != nil {
		logrus.Warnf("%q: %s", chartPath, err)
		return nil, err
	}

	if info.IsDir() {
		return chartimages.DecodeValuesInDir(chartPath)
	}
	return chartimages.DecodeValuesInTgz(chartPath)
}

func (cc *Checker) getChartHelperTemplate(chartURL string) (string, error) {
	info, err := os.Stat(filepath.Join(cc.Path, chartURL))
	if err != nil {
		return "", err
	}
	if info.IsDir() {
		// destination file is a directory
		helpersTplPath := filepath.Join(
			cc.Path, chartURL, "templates", "_helpers.tpl")
		data, err := os.ReadFile(helpersTplPath)
		if err != nil {
			return "", err
		}
		return string(data), nil
	}

	// destination file is a tarball
	tgz, err := os.Open(filepath.Join(cc.Path, chartURL))
	if err != nil {
		return "", err
	}
	defer tgz.Close()
	gzr, err := pgzip.NewReader(tgz)
	if err != nil {
		return "", err
	}
	defer gzr.Close()
	tr := tar.NewReader(gzr)
	var data []byte
	// var headerName string
	for {
		header, err := tr.Next()
		switch {
		case err == io.EOF:
			return "", nil
		case err != nil:
			return "", err
		case header.Typeflag == tar.TypeReg &&
			filepath.Base(header.Name) == "_helpers.tpl":
			data, err = io.ReadAll(tr)
			if err != nil {
				return "", err
			}
			logrus.Debugf("Read: %v", header.Name)
			return string(data), nil
		default:
			continue
		}
	}
}
